import time
import json
import sys
import openai
import streamlit as st
from consts import OPENAI_API_KEY, SETUP_PROMPT, INSTRUCTION_PROMPT, now
from funcs import (
    google_tool,
    browse_website,
    write_to_file,
    append_to_file,
    read_file,
    open_file,
    search_wiki,
    type_message,
    ask_gpt,
    analyse_uploaded_file,
    youtube_transcript
)


tools = {
    "google": google_tool,
    "browse_website": browse_website,
    "write_to_file": write_to_file,
    "append_to_file": append_to_file,
    "read_file": read_file,
    "open_file": open_file,
    "wikipedia": search_wiki,
    "youtube_transcript": youtube_transcript,
    "type_message": type_message
}


# MAIN
def main():
    """
    Starting point of the program.
    """
    # INITIAL SETUP
    st.title("GPT-3.5 for Devs")
    

    if "messages" not in st.session_state:
        st.session_state.messages = []

    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])

    # GETTING USER PROMPT
    prompt = st.chat_input("Enter Task")
    if not prompt:
        sys.exit()
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)

    init_messages = [
        {"role": "system", "content": SETUP_PROMPT},
        {"role": "user", "content": prompt},
    ]
    # FIRST REPLY
    reply = ask_gpt(init_messages)

    prompt1 = f"{reply}\n{INSTRUCTION_PROMPT}\nThe current time and date is {now}"
    init_messages += [
        {
            "role": "system",
            "content": prompt1,
        },
        {
            "role": "user",
            "content": "Determine which next command to use, and respond using the \
                format specified above:",
        },
    ]

    # SECOND REPLY
    init_reply = json.loads(ask_gpt(init_messages), strict=False)

    # DISPLAYING THE OUTPUT TO THE USER
    type_message({"text": init_reply["thoughts"]["text"]})

    def execute(reply) -> str:
        """This is a recursive function which lets GPT run tools provided to it when it needs them.
        Args:
            reply: a dictionary which contains information like thoughts and which tool to use
        Returns:
            str: returns "task_completed" after running completely
        """
        if reply["command"]["name"] == "task_complete":
            print("GPT Has done its work.")
            return "task_completed"
        try:
            time.sleep(5)
            if reply["command"]["name"] == "analyse_uploaded_file":
                try:
                    result = analyse_uploaded_file(st.session_state.uploaded_file,reply["command"]["args"])
                except:
                    result = "This command returned nothing"
            else:
                result = tools[reply["command"]["name"]](reply["command"]["args"])
            messages = [
                {
                    "role": "system",
                    "content": prompt1
                    + "\n"
                    + "This reminds you of these events from your past:\n\
                        I was created and nothing new has happened.",
                },
                {
                    "role": "user",
                    "content": "Determine which next command to use, \
                        and respond using the format specified above:",
                },
                {"role": "assistant", "content": json.dumps(reply)},
                {
                    "role": "system",
                    "content": f"Command {reply['command']['name']} returned: "
                    + result,
                },
                {
                    "role": "user",
                    "content": "Determine which next command to use, \
                        and respond using the format specified above:",
                },
            ]
            reply = json.loads(ask_gpt(messages), strict=False)
            type_message({"text": reply["thoughts"]["text"]})
            execute(reply)

        except Exception as error:
            type_message({"text": f"Task aborted due to error: {error}"})
            return "task_completed"

    execute(init_reply)


if __name__ == "__main__":
    main()
